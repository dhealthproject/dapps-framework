/**
 * This file is part of dHealth dApps Framework shared under LGPL-3.0
 * Copyright (C) 2022-present dHealth Network, All rights reserved.
 *
 * @package     dHealth dApps Framework
 * @subpackage  Backend
 * @author      dHealth Network <devs@dhealth.foundation>
 * @license     LGPL-3.0
 */
// external dependencies
import { Injectable } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import { OnEvent } from "@nestjs/event-emitter";
import moment from "moment";

// internal dependencies
import { AlertEvent } from "../../common/events/AlertEvent";
import { NotifierFactory } from "../concerns/NotifierFactory";
import { AlertsConfig } from "../../common/models/MonitoringConfig";
import { Notifier } from "../models/Notifier";
import { NotifierType } from "../models/NotifierType";
import { LogService } from "../../common/services/LogService";
import { StateService } from "../../common/services/StateService";
import { StateDocument, StateQuery } from "../../common/models/StateSchema";
import { AlertNotifierStateData } from "../models/AlertNotifierStateData";

/**
 * @class AlertNotifier
 * @description The alert notifier that will send a notification when
 * a warn/error log occurs within the application's api and schedulers.
 * <br /><br />
 * This class is in essential an event listener that listens to and handles
 * warning/error events from the {@link LogService}.
 * <br /><br />
 * When handling events, this class utilizes the {@link Notifier} strategy
 * instance to send notification to specified recipient(s) using configured
 * transport method as defined within {@link AlertsConfig}.
 * <br /><br />
 * Currently this class listens and handles these events:
 * | Name | Description |
 * | --- | --- |
 * | `event.log.warn`     | The event in which a warning log occured in the application. |
 * | `event.log.error`    | The event in which an error log occured in the application. |
 *
 * @since v0.5.0
 */
@Injectable()
export class AlertNotifier {
  /**
   * The configuration object in which specifies the type of
   * event, the notification transport and recipient(s) details.
   *
   * @access private
   * @var {AlertsConfig}
   */
  private readonly alertsConfig: AlertsConfig;

  /**
   * The {@link Notifier} strategy of this class. Depending on
   * the transport method specified in the {@link ReportsConfig}
   * this will be generated by the {@link NotifierFactory}.
   *
   * @access private
   * @var {Notifier}
   */
  private readonly notifier: Notifier;

  /**
   * Constructs and prepares an instance of this class.
   *
   * @param {ConfigService}   configService
   * @param {NotifierFactory} notifierFactory
   * @param {StateService} stateService
   */
  constructor(
    private readonly configService: ConfigService,
    private readonly notifierFactory: NotifierFactory,
    private readonly stateService: StateService,
  ) {
    // get config
    this.alertsConfig = this.configService.get<AlertsConfig>("alerts");

    // get the notifier strategy from the configured transport method
    this.notifier = this.notifierFactory.getNotifier(
      this.alertsConfig.transport as NotifierType,
    );
  }

  /**
   * Main method to handle `notifier.alerts.warn` event.
   *
   * @access protected
   * @param event
   * @return {void}
   */
  @OnEvent("notifier.alerts.warn", { async: true })
  protected async handleLogWarnEvent(event: AlertEvent): Promise<void> {
    const logger = new LogService("testing");
    logger.debug(`CAUGHT warn`);
    // get state data and compare last sent event to this event
    const lastAlertEvent = await this.getLastAlertEvent();
    // if they are equal return
    if (
      lastAlertEvent &&
      event.loggerContext === lastAlertEvent.loggerContext &&
      event.message.toString() === lastAlertEvent.message
    ) {
      console.log("logger: ", logger);
      logger.debug(`Warning alert is the same with last alert`);
      return;
    }
    // handle and process "AlertEvent" event
    if (this.alertsConfig.type.includes("warn")) {
      const dappName = this.configService.get<string>("dappName");
      const dappUrl = this.configService.get<string>("frontendApp.url");
      const dateFormat = moment(new Date()).format("YYYY-MM-DD hh:mm:ss");
      await this.notifier.sendInternal({
        to: this.alertsConfig.recipient,
        subject: `[${dappName}] WARNING on dApp (${dappUrl}) at ${dateFormat}`,
        template: "AlertEmailTemplate", // The `.pug` or `.hbs` extension is appended automatically.
        context: {
          // Data to be sent to template engine.
          alertLevel: "WARNING",
          dappUrl,
          dateFormat,
          details: event,
        },
      });
      await this.saveLastAlertEvent(event);
    }
  }

  /**
   * Main method to handle `notifier.alerts.error` event.
   *
   * @access protected
   * @param event
   * @return {void}
   */
  @OnEvent("notifier.alerts.error", { async: true })
  protected async handleLogErrorEvent(event: AlertEvent): Promise<void> {
    const logger = new LogService("testing");
    logger.debug(`CAUGHT error`);
    // get state data and compare last sent event to this event
    const lastAlertEvent = await this.getLastAlertEvent();
    // if they are equal return
    if (
      lastAlertEvent &&
      event.loggerContext === lastAlertEvent.loggerContext &&
      event.message.toString() === lastAlertEvent.message
    ) {
      logger.debug(`Error alert is the same with last alert`);
      return;
    }
    // handle and process "AlertEvent" event
    if (this.alertsConfig.type.includes("error")) {
      const dappName = this.configService.get<string>("dappName");
      const dappUrl = this.configService.get<string>("frontendApp.url");
      const dateFormat = moment(new Date()).format("YYYY-MM-DD hh:mm:ss");
      await this.notifier.sendInternal({
        to: this.alertsConfig.recipient,
        subject: `[${dappName}] ERROR on dApp (${dappUrl}) at ${dateFormat}`,
        template: "AlertEmailTemplate", // The `.pug` or `.hbs` extension is appended automatically.
        context: {
          // Data to be sent to template engine.
          alertLevel: "ERROR",
          dappUrl,
          dateFormat,
          details: event,
        },
      });
      await this.saveLastAlertEvent(event);
    }
  }

  private async getLastAlertEvent() {
    const state = await this.stateService.findOne(
      new StateQuery({ name: AlertNotifier.name } as StateDocument),
    );
    return (state?.data as AlertNotifierStateData)?.lastAlertEvent;
  }

  private async saveLastAlertEvent(alertEvent: AlertEvent) {
    alertEvent.message = alertEvent.message.toString();
    return await this.stateService.updateOne(
      new StateQuery({ name: AlertNotifier.name } as StateDocument),
      { lastAlertEvent: alertEvent },
    );
  }
}
